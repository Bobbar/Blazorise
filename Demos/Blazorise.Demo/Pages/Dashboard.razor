@page "/"
@using System.Diagnostics
@using System.IO
@using Blazorise.Extensions
@inject IVersionProvider VersionProvider

<Field Horizontal>
    <FieldBody>
        <FilePicker @ref=fileEdit
                    Multiple
                    MaxChunkSize=FileEditMaxChunkSize
                    Written=OnFilePartReceived
                    Ended=OnFileUploadEnded
                    Progressed=OnFileUploadProgressChanged
                    Upload="OnFileUpload">
            <Feedback>
                <ValidationError />
                <ValidationSuccess Display="Display.None"></ValidationSuccess>
            </Feedback>
        </FilePicker>
    </FieldBody>
</Field>

@code {
    private Validations validations;


    #region file manipulation

    private readonly int FileEditMaxChunkSize = 23 * 1024;

    private bool FileUploading { get; set; } = false;

    private bool FileUploadCancelled { get; set; } = false;

    private bool FileUploadProgressVisible { get; set; } = false;
    private int FileUploadProgressPercent { get; set; }
    private FilePicker fileEdit { get; set; }
    /// <summary>
    /// Defines if TextEdit or multiline TextEdit (MemoEdit) is used for uploaded document name displayal
    /// </summary>
    private bool SelectedFileNameDisplayMultiline { get; set; } = false;

    #endregion




    /// <summary>
    /// Removes currently selected file from <see cref="FileEdit"/>
    /// <br>Resets uploaded file</br>
    /// <br>Cancels ongoing upload if any</br>
    /// </summary>
    private async Task ResetFile()
    {
        FileUploadProgressVisible = false;
        FileUploading = false;
        FileUploadCancelled = true;
        await fileEdit.FileEdit.Reset().AsTask(); //this does not trigger FileEdit.Ended event on its own and thus upload is not cancelled
    }

    /// <summary>
    /// This function is invoked when upload finishes (ends with sucess)and when a different file is selected during upload (ends with failure).
    /// <br> TODO: find how to properly cancel ongoing upload process, maybe hack with selecting another file programatically?</br>
    /// </summary>
    /// <param name="e"></param>T
    private void OnFileUploadEnded(FileEndedEventArgs e)
    {
        Console.WriteLine($"File {e.File.Name} upload {(e.Success ? "succeeded" : "failed")}.");
    }

    private async Task OnFileUpload(FileUploadEventArgs e)
    {
        var bytes = await TestFileUpload(e.File);
    }

    private async Task OnSelectedFileChanged(FileChangedEventArgs e)
    {
        if (e.Files.Count() == 0)
        {
            return;
        }

        var file = e.Files[0];

        Console.WriteLine("");
        Console.WriteLine($"Changed selected file in FileEdit.");
        Console.WriteLine($"Selected file: {file.Name}, last modified {file.LastModified}, size: {file.Size / 1024} kB");

        try
        {
            //uploads 2 times, buffered and not buffered

            var bytes = await TestFileUpload(file);
            //await fileEdit.FileEdit.Reset();
            //bytes = await TestFileUploadBuffered(file);


        }
        catch (Exception exc)
        {
            Console.WriteLine(exc.Message);
        }
        finally
        {
            StateHasChanged();
        }
    }

    //TEST
    //to be called in the try block in OnSelectedFileChanged
    private async Task<byte[]> TestFileUpload(IFileEntry file)
    {
        Stopwatch s = Stopwatch.StartNew();
        byte[] result = await TryRead(file); //no buffer
        s.Stop();
        Console.WriteLine("file upload without explicit buffering took " + s.ElapsedMilliseconds + " ms");
        return result;
    }

    //TEST
    //to be called in the try block in OnSelectedFileChanged
    private async Task<byte[]> TestFileUploadBuffered(IFileEntry file)
    {
        Stopwatch s = Stopwatch.StartNew();
        byte[] result = await TryReadBuffered(file);
        s.Stop();
        Console.WriteLine("file upload using buffer took " + s.ElapsedMilliseconds + " ms");
        return result;
    }


    private async Task<byte[]> TryRead(IFileEntry file)
    {
        using (var stream = new MemoryStream())
        {
            await file.WriteToStreamAsync(stream);
            stream.Seek(0, SeekOrigin.Begin);
            return stream.ToArray();
        }
    }


    /// <summary>
    /// This upload method does not invoke <see cref="FileEdit.Progressed"/> event
    /// </summary>
    /// <param name="file"></param>
    /// <param name="bufferSizeBytes"></param>
    /// <returns></returns>
    private async Task<byte[]> TryReadBuffered(IFileEntry file, int bufferSizeBytes = 1 * 1024 * 1024)
    {
        var totalParts = Math.Ceiling(file.Size / (double)bufferSizeBytes);
        int readParts = 0;
        var buffer = new byte[bufferSizeBytes];

        using (MemoryStream result = new MemoryStream())
        {
            using (var bufferedStream = new BufferedStream(file.OpenReadStream(long.MaxValue), bufferSizeBytes))
            {
                int currentBytes;
                while ((currentBytes = await bufferedStream.ReadAsync(buffer, 0, bufferSizeBytes)) > 0)
                {
                    readParts++;
                    Console.WriteLine($"Read: {readParts} of {totalParts} (received total: {(readParts * bufferSizeBytes) / (double)(1024 * 1024)} MB)");
                    //do something with bytes
                    result.Write(buffer, 0, currentBytes); //append

                    FileUploadProgressPercent = (int)((readParts / (double)totalParts) * 100);
                    Console.WriteLine($"FileUploadProgress = {FileUploadProgressPercent}");
                }
            }
            return result.ToArray();
        }
    }

    private void OnFilePartReceived(FileWrittenEventArgs e)
    {
        Console.WriteLine($"File part received. Position: {e.Position} Received data size: {e.Data.Length}");
    }

    /// <summary>
    /// This is invoked by <see cref="fileEdit"/> when non-buffered upload is used.
    /// <br>Change is reported upon every new received chunk.</br>
    /// <br>Default chunk size according to Blazorise documentation is 20480 bytes.</br>
    /// <br>There is a bug that chunk size larger than 23*1024 freezes the <see cref="FileEdit"/> component.</br>
    /// </summary>
    private void OnFileUploadProgressChanged(FileProgressedEventArgs e)
    {
        Console.WriteLine($"File upload progress: {e.Percentage:0.0} %");
        if (e.Percentage > 100)
        {
            throw new ArgumentException("FileEdit does not behave as expected");
        }
        FileUploadProgressPercent = (int)e.Percentage;
    }
}